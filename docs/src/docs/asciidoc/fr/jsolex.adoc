= JSol'Ex
Cédric Champeau
:icons: font
:docinfo: shared

JSol'Ex est un traitement d'images solaires produites par l'intermédiaire du http://www.astrosurf.com/solex/[Sol'Ex de Christian Buil].
Il permet de traiter les fichiers SER capturés avec cet instrument pour produire des images du disque solaire, de manière similaire à http://valerie.desnoux.free.fr/inti/[INTI de Valérie Desnoux].
S'il est principalement conçu pour traiter les images produites par Sol'Ex, il est possible qu'il donne de bons résultats sur d'autres héliospectrographes.

JSol'Ex est un logiciel libre sous licence Apache 2, écrit en Java et fourni à titre gratuit sans aucune garantie.

.Note aux utilisateurs français
[IMPORTANT]
====
**Si vous votez Rassemblement National ou tout autre parti proche de l'extrême droite, je vous demande de ne pas utiliser ce logiciel**

Mes convictions sont diamètralement opposées à celles de ces partis et je ne souhaite pas que mon travail, développé sur mon temps libre avec une licence libre serve à des personnes qui soutiennent ces idées nauséabondes.

La solidarité, le partage, l'ouverture aux autres, la lutte contre les discriminations et les inégalités, le respect de toutes les religions, de tous les genres sont les valeurs qui m'animent. Elles sont à l'opposé de celles prônées par ces partis.

Je vous invite à ne pas céder aux sirènes de la haine et à vous tourner vers des valeurs plus positives, où votre bien-être ne passe pas par le rejet de l'autre.
====

== Téléchargement

Cliquez sur le bouton correspondant à votre système ci-dessous :

link:https://jsolex.s3.eu-west-3.amazonaws.com/jsolex-windows-latest/{prefixName}-{version}.msi[icon:windows[] JSol'Ex (Windows), role="badge"]
link:https://jsolex.s3.eu-west-3.amazonaws.com/jsolex-ubuntu-latest/{prefixName}_{version}_amd64.deb[icon:linux[] JSol'Ex (Linux), role="badge"]
link:https://jsolex.s3.eu-west-3.amazonaws.com/jsolex-macos-latest/{prefixName}-{version}.pkg[icon:apple[] JSol'Ex (Mac ARM64), role="badge"]
link:https://jsolex.s3.eu-west-3.amazonaws.com/jsolex-macos-13/{prefixName}-{version}.pkg[icon:apple[] JSol'Ex (Mac Intel), role="badge"]

JSol'Ex peut aussi être téléchargé ou installé depuis les sources sur https://github.com/melix/astro4j/releases[cette page].
Des installateurs sont disponibles pour Linux, Windows et MacOS.

Alternativement, vous pouvez lancer JSol'Ex en téléchargeant les sources puis en exécutant la commande:

[source,bash]
----
./gradlew jsolex:run
----

== Communauté

Vous pouvez nous rejoindre sur notre https://discord.gg/y9NCGaWzve[serveur Discord] pour discuter de JSol'Ex, poser des questions, ou partager vos images.

[link=https://discord.gg/y9NCGaWzve]
image::https://discordapp.com/api/guilds/1305595962663768074/widget.png?style=banner2[]

== Traitement d'une vidéo

JSol'Ex ne peut traiter que les fichiers SER, vous devez donc configurer votre logiciel de capture pour utiliser ce format.
La fenêtre principale se présente sous cette forme:

image::main-window-fr.jpg[]

Dans le menu "Fichier", sélectionnez "Ouvrir un fichier SER".
Choisissez votre fichier, la fenêtre suivante devrait s'ouvrir:

image::params-1-fr.jpg[]

Cette fenêtre est le point d'entrée de la configuration du traitement.
Vous pouvez préciser:

- la longueur d'onde d'observation: s'il n'est pas obligatore de remplir ce champ, le faire vous permettra de bénéficier de la coloration automatique. En cliquant sur les "..." vous disposez de la possibilité d'ajouter vos propres raies si elles ne sont pas listées
- décalage en pixels : par défaut, le logiciel trouve la raie la plus sombre dans l'image et calcule un polynôme de second degré pour modéliser cette raie. L'image est reconstituée en prenant les pixels au centre de la raie (décalage = 0). Il vous est possible d'entrer un décalage en pixels pour aller par exemple vers le continuum, ou trouver une raie plus difficile à identifier (ex. Hélium) à partir de la raie la plus sombre.
- le décalage Doppler est utilisé uniquement lorsque vous observez en raie h-alpha pour générer une image Doppler. Par défaut, le logiciel utilise 2 images décalées de 3 pixels pour reconstituer une image en couleur.
- Correction angle P : lorsque cette case est cochée, l'angle P du soleil sera calculé automatiquement à partir de la date d'observation (disponible dans le fichier SER). Les images seront automatiquement corrigées de cet angle, pour que le Nord soit bien en haut. Ce paramètre n'affecte pas les images générées avec ImageMath, qui doivent faire leur propre correction.
- Rotation : permet d'effectuer une rotation à gauche ou à droite (90 degrés) de l'image. Ceci peut par exemple être utile dans le cas d'un scan fait en déclinaison, pour corriger l'orientation. Ce paramètre n'affecte pas les images crées avec ImageMath.
- Rognage : permet d'effectuer un rognage automatique de l'image après correction géométrique. Il existe plusieurs modes:
* Aucun: pas de rognage (par défaut)
* Largeur d'origine : l'image sera redimensionnée dans un carré de la taille de la largeur de la vidéo d'origine. Idéal pour les disques solaires complets.
* Rayon (x...) : l'image sera redimensionnée en fonction du rayon du disque solaire, en appliquant un multiplicateur. Peut-être utile par exemple lorsque le disque est tronqué et que l'on veut avoir une image carrée permettant de "remettre" la portion à sa place.
- Forcer la valeur du tilt : lors de la correction géométrique d'image, JSol'Ex calcule une ellipse pour modéliser le disque solaire reconstitué. Cette ellipse est utilisée pour calculer des paramètre comme l'angle de tilt. Si le calcul effectué par le logiciel est erroné, vous disposez de la possibilité de surcharger la valeur calculée.
- Forcer le rapport X/Y : de manière similaire, sur certaines images dans des raies difficiles, l'ellipse peut ne pas parfaitement correspondre au disque solaire et ne pas reconstituer un soleil parfaitement circulaire. Vous pouvez surcharger le rapport détecté pour corriger ces problèmes
- Forcer le polynôme: permet de forcer le polynôme de second degré utilisé pour modéliser la raie spectrale. Voir la <<#force-polynomial,section sur le forçage du polynôme>> pour plus d'informations.
- Inverser l'axe horizontal/vertical : permet de retourner l'image verticalement et horizontalement pour avoir le Nord et l'Est bien orientés
- Redimensionner au maximum: peut être utilisé si votre vidéo est sur-échantillonnée et que vous souhaitez conserver la résolution maximum. Ceci arrive par exemple si vous faites des scans à basse vitesse (ex, sidérale).

WARNING: Activer ce paramètre peut produire des images sensiblement plus grandes et entraîner une forte pression mémoire. Il n'est pas recommandé d'activer ce paramètre.

== Paramètres d'amélioration de l'image

Cette section permet de configurer les transformations qui seront appliqueés aux images de façon à améliorer leur aspect esthétique.

image::params-2-fr.jpg[]

- Paramètres CLAHE : permet de configurer l'algorithme d'amélioration de contraste CLAHE.
Il est possible de configurer la taille des tuiles utilisées pour calculer les histogrammes, la résolution de l'histogramme et le facteur de clipping.

Viennent ensuite les paramètres de correction de bandes, qui permettent de corriger les bandes transversales qui peuvent apparaître sur les images par exemple à cause de poussières sur la fente.

- Largeur de correction de bande : c'est la largeur des bandes qui sont utilisées pour l'algorithme de correction de transversallium. L'algorithme calcule la valeur moyenne des pixels dans ces bandes et corrige la luminosité d'une ligne en fonction de cette valeur.
- Nombre de passes de correction de bande : plus vous ferez de passes, plus il sera possible de corriger de gros défauts, au prix d'une image moins contrastée et/ou moins lumineuse

Une autre section permet de configurer la déconvolution des images.
Par défaut, aucune déconvolution n'est appliquée, mais vous pouvez choisir l'agorithme de déconvolution et ses paramètres.

Pour la déconvolution de Richardson-Lucy, vous pouvez choisir la taille du PSF synthétique, le facteur sigma et le nombre d'itérations.

Enfin, vous pouvez choisir d'appliquer un filtre d'amélioration des détails à la fin du traitement en cochant la case "aiguiser les images".

[NOTE]
.Expérimental
====
La correction par flat artificiel permet de corriger un éventuel vignettage. Elle calcule un modèle à partir des pixels du disque. Les pixels considérés sont ceux dont la valeur est comprise entre un percentile bas et un percentile haut. Par exemple, si vous entrez 0.1 et 0.9, les pixels dont la valeur est comprise entre le 10ème et le 90ème percentile seront utilisés pour calculer le modèle. Enfin, un polynome d'ordre spécifié est ajusté sur les valeurs du modèle pour corriger l'image.
====

== Paramètres d'observation

Les paramètres d'observation sont utilisés lorsque vous enregistrez vos images au format FITS, pour remplir certaines métadonnées.
Elles servent aussi à calculer le graphique de longueur d'ondes.
A noter qu'à ce stade, nous ne recommandons pas d'envoyer les images générées par JSol'Ex sur la base de données BASSS2000, les champs de métadonnées entrés n'étant pas exactement les mêmes.

image::params-3-fr.jpg[]

Voici les champs disponibles dans JSol'Ex:

- Observateur : personne qui a effectué l'observation
- Adresse email : adresse e-mail de l'observateur
- Instrument : pré-rempli avec "Sol'Ex"
- Télescope : votre lunette ou télescope utilisé avec votre Sol'Ex
- Longueur focale et ouverture
- Latitude et longitude du site d'observation
- Caméra
- Date : pré-rempli avec les métadonnées du fichier SER, en zone UTC
- Binning : le binning appliqué à la caméra lors de l'acquisition
- Taille des pixels : la taille des pixels de la caméra, en microns
- Inversement haut/bas du spectre : normalement, le spectre doit avoir l'aile bleue en haut et l'aile rouge en bas. Si c'est l'inverse, vous pouvez cocher cette case. C'est typiquement le cas si vous utilisez un Sunscan.
- Mode altazimutal : cochez cette case si vous n'utilisez pas une monture équatoriale mais une monture altazimutale (typiquement le cas avec Sunscan).

[IMPORTANT]
.Mode altazimutal et correction de l'orientation des images
====
Il est important de comprendre que JSol'Ex n'est pas capable de déterminer si une image est retournée verticalement ou horizontalement, mais il peut calculer l'angle solaire P à partir de la date d'observation.
Cependant, la grille d'orientation qui est générée ne sera correcte que si vous utilisez une monture équatoriale.
Si vous utilisez une monture altazimutale, l'oritentation sera incorrecte, ainsi que la position des étiquettes des régions actives détectées.
Pour corriger cela, vous devez cocher la case "mode altazimutal" et entrer les coordonnées de votre site d'observation : JSol'Ex calculera alors l'angle parallactique et effectuera la correction automatiquement, donnant une image bien orientée.
====

== Autres paramètres disponibles

image::params-4-fr.jpg[]

- Supposer vidéo mono : si cette cache est cochée, JSol'Ex n'essaiera pas de faire un dématriçage de la vidéo d'entrée, ce qui permet d'accélérer considérablement les temps de traitement. En règle générale, vos vidéos seront en mono, il est donc utile de conserver cette case cochée.
- Enregistrement automatique des images : si cette case est cochée, toutes les images générées sont automatiquement enregistrées sur disque. Dans le cas contraire, vous devrez dans l'interface qui affiche les images générés appuyer sur le bouton "Enregistrer" pour conserver les images produites
- Générer des images de debug : permet de générer des images telles que la reconnaissance de contours, la reconnaissance d'ellipse/tilt, l'image moyenne. Utile pour vérifier si le logiciel ne se comporte pas correctement sur votre vidéo et que vous souhaitez vérifier là où il se trompe
- Générer des fichiers FITS : permet de générer des fichiers FITS, non destructifs, en plus des images PNG

[[force-polynomial]]
== Forcer le polynôme

JSol'Ex effectue une détection de la raie spectrale en cherchant la ligne la plus sombre dans l'image, puis en ajustant un polynôme de 3ème ordre.
Il arrive parfois que la détection soit incorrecte, auquel cas vous pouvez forcer l'utilisation d'un polynôme.
Pour ce faire, cliquez sur le bouton "forcer le polynôme", qui vous permettra d'entrer les coefficients du polynôme.

Le format du polynôme est une liste de 4 nombres entre accolades, séparés par des virgules, par exemple: `{1.3414109042116584E-10,3.889927699830093E-5,-0.056529799336687114,35.76051527062038}`.

La façon la plus simple d'obtenir les coefficients du polynôme est de cliquer sur les "..." qui ouvrira une fenêtre avec l'image moyenne et la raie spectrale détectée :

image::force-polynomial-1.jpg[]

Vous pouvez alors appuyer sur "CTRL" puis cliquer sur la ligne pour ajouter des points de mesure : une croix rouge sera ajoutée pour chaque point.
Lorsque vous avez suffisamment de points, cliquez sur le bouton "Calculer le polynôme", qui ajustera un polynôme de 3ème ordre aux points et remplira automatiquement le champ "polynôme de force" dans les paramètres de traitement :

image::force-polynomial-2.jpg[]

You can then close the popup and start processing.


[[modele-noms-fichier]]
== Modèles de noms de fichier

Par défaut, JSol'Ex enregistre les images produites dans un sous-dossier correspondant au nom de la vidéo, et dans ce sous-dossier un autre sous-dossier par type d'image (raw, debug, traitées, etc...).
Si ce modèle ne vous convient pas, vous pouvez créer vos propres modèles de nommage, en cliquant sur les "...":

image::params-5-fr.jpg[]

Un modèle de nommage consiste en un label (un nom), mais surtout un modèle dont les composantes sont des jetons entre `%`.

Voisi les jetons disponibles:

- `%BASENAME%` est le nom de base du fichier SER, sans l'extension
- `%KIND%` correspond au type d'image générée (raw, debug, ...)
- `%LABEL%` est l'identifiant des images, par exemple `recon`, `protus`, etc...
- `%CURRENT_DATETIME%` est la date et l'heure de traitement
- `%CURRENT_DATE%` est la date de traitement
- `%VIDEO_DATETIME%` est la date et heure de la vidéo
- `%VIDEO_DATE%` est la date de la vidéo
- `%SEQUENCE_NUMBER%` est le numéro de séquence dans le cas d'un traitement en mode batch (avec 4 chiffres, par ex. `0012`)

Par exemple, pour créer un modèle pour mettre toutes vos images dans un même dossier peut être :

`%BASENAME%/%SEQUENCE_NUMBER%_%LABEL%`

Le champ "exemple" donne une idée de ce qui sera généré.

== Lancer un traitement

Vous avez le choix entre 3 modes de traitement.

- Le mode "rapide" ne produira que 2 images : l'image brute reconstituée, qui permet de se donner une idée de la circularité du disque et donc du potentiel sous-échantillonage, et une image corrigée géométriquement. C'est un mode particulièrement utile lors des premières acquisitions, par exemple de temps de régler le tilt correctement. Combiné au fait de ne pas sauvegarder automatiquement les images, il peut vous faire gagner un temps précieux et de l'espace disque !
- Le mode "complet" produira l'intégralité des images que peut produire JSol'Ex. En fonction de la raie spectrale choisie, certaines images seront disponibles ou non. Par défaut, le logiciel produira:
    - l'image brute reconstituée
    - une version géométriquement corrigée et "étalée" (contraste amélioré)
    - une version colorisée (si la raie choisie dispose d'un profil de colorisation)
    - une version en négatif
    - une éclipse virtuelle, permettant de simuler un coronagraphe
    - une version "mix" combinant l'éclipse virtuelle et l'image colorisée
    - une image Doppler
- le mode "personnalisé" permet de choisir plus précisément les images générées, voire de générer des images non prévues à l'origine par le logiciel (voir la <<#custom_images,section suivante>>).

=== Affichage des images produites

Lorsque les images sont produites, elles apparaissent au fur et à mesure en onglets.
Il vous est alors possible, en fonction des images, de modifier des paramètres de contraste et d'enregistrer les images.

image::image-display-fr.jpg[]

Vous pouvez zoomer dans les images en utilisant la molette de la souris.
Un clic droit vous permettra d'ouvrir l'image générée dans votre explorateur de fichiers ou dans une nouvelle fenêtre.

== Mode surveillance de répertoire

Lors de la mise au point, il peut être utile de traiter "à la chaîne" de nouvelles vidéos jusqu'à avoir obtenu un résultat satisfaisant (image centrée, mise au point correcte, etc.).
JSol'Ex offre une façon simple de gagner du temps, en surveillant un dossier : les vidéos qui apparaissent dans le dossier seront automatiquement traitées.

Pour ce faire, dans le menu fichier, sélectionnez "Surveiller un dossier" puis sélectionnez le dossier dans lequel seront enregistrés vos fichiers SER (par exemple là où SharpCap va enregistrer).

JSol'Ex bascule en mode "surveillance" que vous pouvez interrompre en cliquant sur le bouton en bas à gauche.

Ouvrez maintenant votre logiciel de capture et enregistrez une nouvelle vidéo.
Lorsque vous rebasculerez sur JSol'Ex, le logiciel ouvrira automatiquement la fenètre de paramétrage.
Choisissez vos options et lancez le traitement.

Une fois le résultat obtenu, rebasculez sur le logiciel d'acquisition et enregistrez une nouvelle vidéo.
Lorsque vous rebasculerez sur JSol'Ex, cette fois-ci le logiciel réutilisera les paramètres utilisés lors du traitement de la première vidéo : vous obtiendrez donc rapidement une nouvelle image !

WARNING: Lorsque vous basculez de votre logiciel de capture à JSol'Ex, faites attention à ce que l'enregistrement soit terminé. Dans le cas contraire, le traitement serait lancé sur un fichier SER incomplet, ce qui échouera.

Lorsque vous avez terminé, cliquez sur le bouton "Interrompre la surveillance" en bas à gauche.

TIP: Vous pouvez combiner le fait d'être en mode surveillance avec le fait d'ouvrir une image dans une fenêtre externe (en faisant un clic droit sur l'image choisie). En effet, lors du traitement de la nouvelle vidéo, l'image dans la fenêtre sera automatiquement remplacée par la nouvelle version. Ceci peut par exemple être intéressant dans des présentations publiques, en ayant une fenêtre montrant simplement le résultat du traitement.

[[custom_images]]
== Personnalisation des images générées

Lorsque vous cliquez sur "Personnalisé" au lieu des modes "rapide" ou "complet", JSol'Ex vous permet de choisir bien plus précisément quelles images généres.

Il existe 2 modes : le mode _simple_ et le mode _ImageMath_.

Dans le mode simple, vous pouvez choisir la liste des images générées en cochant chacune d'entre elles, et vous pouvez aussi demander la génération d'images avec des décalages de pixels différents.

Par exemple, si vous souhaitez disposer d'images allant du continuum en passant par la raie explorée, vous pouvez entrer `-10;-9;-8;-7;-6;-5;-4;-3;-2;-1;0;1;2;3;4;5;6;7;8;9;10` ce qui aura pour effet de générer 21 images distinctes, pour des décalages de pixels entre -10 et 10.

Ceci peut être intéressant par exemple si vous les recombinez pour en faire un GIF animé ou une vidéo.

A noter que si vous cochez certaines images comme "Doppler", certains décalages sont automatiquement ajoutés à la liste (ex. -3 et 3).

Si ceci ne suffit pas, vous pouvez utiliser le mode avancé "ImageMath" qui est extrêmement puissant tout en restant simple d'accès.

[[imagemath]]
== ImageMath : scripts de calcul d'images
=== Introduction à ImageMath

Le mode ImageMath permet de générer des images en effectuant des calculs plus ou moins complexes sur des images générées.
Il repose sur un langage de script _simple_ mais suffisamment riche pour faire des traitement complexes.

Reprenons l'exemple précédent, dans lequel il s'agissait de générer l'ensemble des images pour des décalages allant de -10 à 10 pixels.
Dans le mode "simple", il nous a fallu entrer l'ensemble des valeurs à la main, séparés par des points-virgule.
Dans le mode "ImageMath", nous disposons d'un langage permettant de le faire.

Commençez par sélectionner le mode `ImageMath` dans la liste et cliquez sur "Ouvrir ImageMath".
L'interface suivante s'ouvre:

image::imagemath-1-fr.jpg[]

Dans la partie gauche, "Scripts à exécuter", nous trouvons la liste des scripts qui seront appliqués lors du traitement.
Les scripts sont des fichiers enregistrés sur votre disque, que vous pouvez partager avec d'autres utilisateurs.
Leur contenu est éditable dans la partie droite de l'interface.

Effacez le contenu du script d'exemple et remplacez le par:

[source]
----
range(-10;10)
----

Puis cliquez sur "sauvegarder".
Choisissez un fichier de destination et enregistrez.
Le script apparaît désormais dans la liste de gauche, il sera appliqué lors du traitement.

Cliquez alors sur "Ok" pour fermer "ImageMath" et ne conservez que "Après correction géométrique et étendue" dans la liste des images.

Cliquez sur "Ok" pour lancer le traitement, vous obtenez alors les images demandées:

image::imagemath-2-fr.jpg[]

=== Les fonctions d'ImageMath

Nous avons utilisé ici une seule fonction, `range`, qui a permis de générer en une seule instruction une vingtaine d'images, mais il existe de nombreuses fonctions.

Fonctions "unitaires":

- `img` demande une image à un décalage de pixels donné. Par exemple, `img(0)` est l'image centrée sur la raie, `img(-10)` est celle décalée de 10 pixels vers le haut.
- `list` crée une liste à partir des arguments. Par exemple `list(img(-3), img(3))`
- `concat` joint des listes d'images en une seule liste. Par exemple, `concat(list(img(-3), img(3)), list(img(-5), img(5)))` renverra une liste d'images contenant les images à -3, 3, -5 et 5 pixels.
- `get_at` récupère une image de la liste. Par exemple, `get_at(list(img(-3), img(3)), 1)` renverra l'image à l'index 1, qui est `img(3)`. Si l'argument est une liste de listes d'images, alors il renverra une liste qui contient les images à l'index spécifié.
- `avg` permet de calculer la valeur moyenne d'images, par exemple: `avg(img(-1), img(0), img(1))` calcule la moyenne des images aux décalages -1, 0 et 1. Il est aussi possible d'écrire: `avg(range(-1,1))`
- `max` permet de calculer la valeur maximale d'images, par exemple `max(img(-3), img(3))`. Le maximum est calculé pixel par pixel.
- `min` permet de calculer la valeur minimale d'images, par exemple `min(img(-3), img(3))`. Le minimum est calculé pixel par pixel.
- `range` permet de générer une suite d'images à des pixels décalés. Cette fonction prend au minimum 2 arguments, la valeur basse (inclue) et la valeur haute (inclue). Par exemple, `range(-5,5)` produira 11 images. Il est possible de générer une image tous les X pixels, en ajoutant un 3ème argument, le pas. Par exemple, `range(-5,5,5)` ne générera plus que 3 images, à -5, 0 et 5 pixels.
- `pow` permet de calculer une puissance d'une image. Par exemple, `pow(img(0), 2)` calcule le carré de l'image.
- `log` permet de calculer le logarithme d'une image. Par exemple, `log(img(0), 2)` calcule le logarithme en base 2.
- `exp` permet de calculer l'exponentielle d'une image. Par exemple, `exp(img(0))`.

Il est possible de faire des calculs sur les images, par exemple:

`(img(5)+img(-5))/2` est équivalent à `avg(img(5),img(-5))`.

Ou encore: `0.8*img(5) + 0.2*avg(range(0;10))`

Les autres fonctions disponibles sont:

- `adjust_gamma` permet d'appliquer une correction gamma à une image. Cette fonction accepte 2 paramètres : l'image et le facteur de correction gamma. Par exemple, `adjust_gamma(img(0), 2.2)`. Un gamma < 1 éclaircit l'image, un gamma > 1 la fonce.
- `auto_contrast` est une fonction d'amélioration du contraste crée spécifiquement pour les images Sol'Ex. Elle combine plusieurs techniques pour améliorer l'image. Cette fonction prend 2 arguments : l'image et un facteur de correction. Le facteur doit être supérieur à 1 et plus il est élevé, plus la correction sera forte. Par exemple : `auto_contrast(img(0), 1.5)`.
- `invert`, qui permet d'obtenir le négatif d'une image
- `invert`, generates a color inverted image
- `clahe` applique une https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE[transformation d'histogramme adaptative (CLAHE)] sur votre image. Cette fonctiona accepte soit 2, soit 4 arguments. Dans la version courte, elle prend l'image et un facteur de clipping. Par exemple: `clahe(img(0); 1.5)`. Dans sa version longue, elle accepte 2 paramètres supplémentaires: la taille des tuiles utilisées pour calculer les histogrammes et la résolution de l'histogramme. Plus la résolution est élevée, plus la dynamique est élevée, mais plus vous devrez utiliser des tuiles petites. Par exemple: `clahe(img(0); 128; 256; 1.2)`.
- `adjust_contrast` permet d'appliquer un ajustement très simple du contraste, en coupant les pixels sous une limite minimale ou au-dessus de la limite maximale. Par exemple: `adjust_contrast(img(0), 10, 210)`. L'intervalle doit être entre 0 et 255.
- `asinh_stretch` permet d'appliquer la fonction d'étirement par arcsinus hyperbolique. Elle prend 3 paramètres: l'image, le point noir et le coefficient de stretch. Par exemple, `asinh_stretch(img(0), 200, 100)`.
- `linear_stretch` augmente la plage dynamique d'une image. Elle prend soit 1, soit 3 paramètres : l'image, puis optionellement les valeurs min et max des pixels (valeur comprise entre 0 et 65535). Par exemple: `linear_stretch(img(0))`
- `fix_banding` permet d'appliquer l'algorithme de corrections de bandes (ou transversallium). Il prend 3 arguments: l'image, la largeur de bande et le nombre d'itérations. Par exemple, `fix_banding(img(0), 10, 5)`.
- `remove_bg` permet de supprimer l'arrière plan d'une image. Ceci peut être utile lorsque le contraste est très faible (par exemple en raie hélium). Le processus calcule la valeur moyenne des pixels en dehors du disque, puis applique une suppression de l'arrière plan en fonction de la distance au limbe. Par exemple: `remove_bg(stretched)`. Une variante est disponible avec une tolerance: `remove_bg(stretched, 0.2)`. Plus la tolérance est proche de 0, moins la suppression est forte.
- `neutralize_bg` est une fonction similaire à `remove_bg` qui utilise une modélisation polynomiale du fond pour supprimer les gradients. Elle prend en paramètre l'image à traiter, et optionellement un nombre d'itérations en 2ème paramètre. Par exemple : `neutralize_bg(img(0), 2)`.
- `bg_model` crée un modèle de fond de ciel à partir d'une image, qui peut par exemple être soustraite de l'image d'origine. Elle prend en paramètre l'image à traiter, ainsi qu'un ordre de polynôme. Par exemple: `bg_model(img(0))`. L'ordre par défaut est 2. Il n'est pas recommandé d'utiliser un ordre supérieur à 3.

NOTE: Si vous ne connaissez pas la valeur du point noir, vous pouvez utiliser la valeur estimée par JSol'Ex, disponible dans une variable prédéfinie `blackPoint`: `asinh_stretch(img(0), blackPoint, 100)`

- `crop` permet de réduire l'image aux dimensions souhaitées. Cette fonction prend 5 paramètres: l'image à réduire, les coordonnées du point en haut à gauche, puis la largeur et la hauteur de l'image souhaitée. Par exemple: `crop(img(0), 100, 100, 300, 300)`.
- `crop_rect` permet de réduire l'image aux dimensions indiquées, en garantissant que le centre du disque solaire sera au centre de l'image. Par exemple: `crop-rect(img(0), 1024, 1024)`. Il n'y a pas de changement d'échelle : si le disque solaire n'entre pas dans les dimensions cibles, il sera tronqué.
- `autocrop2` effectue un rognage carré de l'image, centré sur le disque solaire, de manière similaire à `autocrop`, mais les dimensions de l'image rognée sont calculées avec un facteur du diamètre du disque. Par défaut, les dimensions de l'image rognée sont un multiple de 16. Par exemple, `autocrop2(img(0);1.1)` rognera autour de 1,1 fois le diamètre. `autocrop2(img(0);1.1;32)` fera la même chose, mais l'image résultante aura une largeur et une hauteur comme multiples de 32.
- `colorize` permet de coloriser une image. Elle prend au choix 2 ou 7 paramètres. Dans sa version la plus simple à 2 paramètres, le premier est l'image à coloriser, et le second est le nom du profil de colorisation, tel que trouvé dans la fenêtre de paramétrage, par exemple: `colorize(img(0), "h-alpha")`. Dans sa version longue, les paramètres de colorisation sont les points "entrée" et "sortie" pour chacun des canaux rouge, bleu et vert, entre 0 et 255. Par exemple: `colorize(img(0), 84, 139, 95, 20, 218, 65)` est équivalent à l'entrée précédente. Notez que la colorisation varie fortement en fonction des images en entrée et qu'il _peut_ être nécessaire d'avoir appliqué la fonction `asinh_stretch` avant pour obtenir les couleurs souhaitées.
- `rgb` permet de créer une image RGB à partir de 3 images mono. Elle prend donc 3 paramètres, par exemple: `rgb(img(3), avg(img(3), img(-3)), img(-3))`.
- `get_r`, `get_g` et `get_b` permettent d'extraire respectivement le canal rouge, vert ou bleu d'une image couleur. Au cas où une image mono est passée en paramètre, elle est renvoyée telle quelle.
- `mono` convertit une image couleur en mono en utilisant la formule gris=0.299 * Rouge + 0.587 * Vert + 0.114 * Bleu
- `saturate` permet de (dé)saturer une image RGB. Elle accepte 2 paramètres : une image couleur et un facteur de saturation (relatif à la saturation courante de l'image). Par exemple: `saturate(doppler, 2)`.
- `anim` permet de créer une animation vidéo à partir de vos images individuelles. Elle accepte une list d'images en premier argument, et en 2ème optionnel le délai entre chaque image (par défaut 250ms). Par exemple `anim(range(-5;5))`. Attention: la création d'animations demande beaucoup de ressources système.
- `load` charge une image depuis le système de fichiers. Elle prend le chemin vers le fichier en paramètre. Par exemple: `load("/chemin/vers/une/image.png")`. Au lieu d'utiliser un chemin complet, il est possible de combiner avec la fonction `workdir`.
- `load_many` permet de charger plusieurs images d'un coup, à partir d'un dossier. Par exemple: `load_many("/chemin/vers/dossier")`. Un paramètre optionnel accepte une expression régulière pour filtrer les images: `load_many("/chemin/vers/dossier", ".\*cropped.*")`.
- `workdir` définit le dossier de travail par défaut. Il est notamment utilisé pour charger les images avec `load`. Par exemple: `workdir("/chemin/vers/dossier/images")`.
- `choose_file` permet à l'utilisateur de choisir une image depuis le système de fichiers. Elle prend 2 paramètres : un identifiant et un message d'aide. L'identifiant est utilisé pour se souvenir du dernier dossier utilisé. Par exemple : `choose_file("myImage", "Choisissez une image")`. Le message ne peut pas être vide.
- `choose_files` permet à l'utilisateur de choisir plusieurs images depuis le système de fichiers. Elle prend 2 paramètres : un identifiant et un message d'aide. L'identifiant est utilisé pour se souvenir du dernier dossier utilisé. Par exemple : `choose_files("myImage", "Choisissez plusieurs images")`. Le message ne peut pas être vide.
- `rl_decon` applique l'algorithme de déconvolution de Richardson-Lucy à l'image. Cette fonction utilise un PSF synthétique. Au minimum, cette fonction accepte un paramètre : l'image. Par exemple : `rl_decon(img(0))`. 3 autres paramètres optionnels sont disponibles : le rayon du PSF en pixels, le facteur sigma et le nombre d'itérations. Par exemple: `rl_decon(img(0), 2.5, 2.5, 10)`.
- `sharpen` applique un filtre d'augmentation des détails à votre image. Exemple: `sharpen(img(0))`. Elle accepte un paramètre optionnel, la taille du noyau de convolution, qui doit être un nombre impair > 3. Par exemple: `sharpen(img(0), 5)`.
- `blur` applique un flou gaussien à votre image. Par exemple : `blur(img(0))`. Elle accepte un paramètre optionnel, la taille du noyau de convolution, qui doit être un nombre impair > 3. Par exemple: `blur(img(0), 5)`.
- `disk_fill` remplit le disque solaire détecté avec une valeur donnée (par défault, celle du point noir détecté). Par exemple `disk_fill(img(0))` ou `disk_fill(img(0), 0)`.
- `disk_mask` crée un masque du disque solaire, où les pixels à l'intérieur du disque auront la valeur 1, contre 0 pour ceux à l'extérieur du disque. Il est possible d'inverser (0 à l'intérieur, 1 à l'extérieur) en passant `1` comme 2d paramètre de la fonction. Par exemple : `disk_mask(img(0);1)`.
- `rescale_rel` permet d'agrandir ou réduire la taille d'une image. Elle prend 3 paramètres: l'image, puis les facteurs d'agrandissement en X et Y. Par exemple, `rescale_rel(img(0);2;2)` pour doubler la taille d'une image.
- `rescale_abs` permet d'agrandir ou réduire la taille d'une image. Elle prend 3 paramètres: l'image, puis les dimensions finales souhaitées. Par exemple, `rescale_abs(img(0);2048;2048)`.
- `radius_rescale` est une méthode de redimensionnement relative qui peut être utile pour faciliter les mosaïques d'images. Elle sera donc typiquement utilisée en <<#batch-mode,traitement par lots>>. Elle permet de redimensionner un ensemble d'images pour que toutes aient le même rayon solaire. Elle procède à une recherche du disque pour chaque image, trouve celle qui a le disque le plus grand, et redimensionne toutes les autres images pour qu'elles aient le même rayon solaire. Par exemple: `radius_rescale(cropped)`.

Fonctions de rotation :

TIP: Une variable spéciale nommée `angleP` contient la valeur calculée pour l'angle P en fonction de la date d'observation. Elle est exprimée en radians et peut typiquement être utilisée avec la fonction `rotate_rad` pour effectuer une correction.

- `rotate_left` effectue une rotation vers la gauche de l'image. Par exemple, `rotate_left(img(0))`.
- `rotate_right` effectue une rotation vers la droite de l'image. Par exemple, `rotate_right(img(0))`.
- `rotate_deg` effectue une rotation d'un angle arbitraire en degrés. Elle accepte entre 2 et 4 paramètres: l'image, l'angle de rotation sont obligatoires. Par exemple `rotate_deg(img(0), 45)`. Vous pouvez ensuite spécifier la valeur du fond à utiliser pour remplir les portions manquantes:  `rotate_deg(img(0), 45, 800)` et enfin si vous ajoutez `1` en dernier paramètre l'image sera redimensionnée au maximum pour que tous les pixels de l'image d'origine apparaissent dans l'image tournée.
- `rotate_rad` effectue une rotation d'un angle arbitraire en radians. Elle accepte entre 2 et 4 paramètres: l'image, l'angle de rotation sont obligatoires. Par exemple `rotate_rad(img(0), .2)`. Vous pouvez ensuite spécifier la valeur du fond à utiliser pour remplir les portions manquantes:  `rotate_rad(img(0), .2, 800)` et enfin si vous ajoutez `1` en dernier paramètre l'image sera redimensionnée au maximum pour que tous les pixels de l'image d'origine apparaissent dans l'image tournée.
- `vflip` permet de retourner l'image verticalement. Par exemple, `vflip(img(0))`.
- `hflip` permet de retourner l'image horizontalement. Par exemple, `hflip(img(0))`.

Fonctions décoratives

- `draw_globe` dessine un globe dont l'orientation et le diamètre correspond aux paramètres solaires détectés. Elle prend entre 1 et 4 paramètres. Le premier est l'image sur laquelle dessiner le globe. Par exemple: `draw_globe(img(0))`. Les paramètres optionnels suivants sont l'angle P (en radians), l'angle B0 (en radians) et l'ellipse du disque solaire. Par exemple: `draw_globe(img(0), p, b0, ellipse)`.
- `draw_obs_details` affiche sur l'image les données d'observation. Par exemple: `draw_obs_details(img(0))`. Par défaut, positionné en haut à gauche. Il est possible de spéficier les coordonnées (x,y) où écrire : `draw_obs_details(img(0), 100, 100)`.
- `draw_solar_params` affiche sur l'image les paramètres solaires. Par exemple: `draw_solar_params(img(0))`. Par défaut, positionné en haut à droite. Il est possible de spéficier les coordonnées (x,y) où écrire : `draw_solar_params(img(0), 500, 100)`.
- `draw_text` imprime du texte sur l'image. Cette fonction prend 3 arguments obligatoires : l'image, la position où imprimer le texte, le texte à écrire. Par exemple : `draw_text(img(0), 100, 100, "Hello World")`. Elle accepte également 2 paramètres optionnels : la taille de la police et la couleur. Par exemple : `draw_text(img(0), 100, 100, "Hello World", 24, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB. Si le texte est entouré de `\*` alors il sera imprimé en gras. Par exemple, `draw_text(img(0), 100, 100, "\*Hello World\*")`. Si le texte est entouré de `\_` alors il sera imprimé en italique. Par exemple, `draw_text(img(0), 100, 100, "\_Hello World\_")`.
- `draw_arrow` dessine une flèche sur l'image. Cette fonction prend 5 arguments obligatoires : l'image, les points de départ et d'arrivée de la flèche. Par exemple : `draw_arrow(img(0), 100, 100, 200, 200)`. Elle accepte également 2 paramètres optionnels : l'épaisseur de la flèche et la couleur. Par exemple : `draw_arrow(img(0), 100, 100, 200, 200, 2, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB.
- `draw_circle` dessine un cercle sur l'image. Cette fonction prend 4 arguments obligatoires : l'image, le centre du cercle et le rayon. Par exemple : `draw_circle(img(0), 100, 100, 50)`. Elle accepte également 2 paramètres optionnels : l'épaisseur du cercle et la couleur. Par exemple : `draw_circle(img(0), 100, 100, 50, 2, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB.
- `draw_rect` dessine un rectangle sur l'image. Cette fonction prend 5 arguments obligatoires : l'image, les coordonnées du coin supérieur gauche, la largeur et la hauteur. Par exemple : `draw_rect(img(0), 100, 100, 200, 200)`. Elle accepte également 2 paramètres optionnels : l'épaisseur du rectangle et la couleur. Par exemple : `draw_rect(img(0), 100, 100, 200, 200, 2, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB.
- `draw_earth` dessine la Terre sur l'image, à l'échelle du disque solaire. Cette fonction prend 3 paramètres : l'image et les coordonnées (x,y) où dessigner la Terre. Par exemple: `draw_earth(img(0), 100, 100)`.

Fonctions d'empilement et de création de mosaiques :

- `stack` permet d'empiler des images. Elle aligne les images et calcule la valeur médiane de chaque pixel. Elle accepte entre 1 et 4 paramètres. Le premier est la liste des images à empiler, par exemple: `stack(load_many("\*.fits"))`. Le 2ème paramètre est la taille des tuiles et le 3ème est le facteur d'échantillonnage (>0). Par exemple, si le facteur d'échantillonnage est de 0,5 et la taille de la tuile de 32 pixels, alors un échantillon sera pris tous les 16 pixels. Le 4ème paramètre est la méthode de sélection de la référence, qui est l'une des suivantes : `first` (première image de la liste), `sharpness` (l'image la plus nette), `average` (calcule la moyenne de toutes les images), `median` (calcule la médiane de toutes les images) ou `eccentricity` (choisit l'image la plus proche d'un cercle). Par exemple : `stack(load_many("\*.fits"), 32, 0.5, "sharpness")`. Par défaut, la méthode de sélection de la référence est `sharpness`.
- `stack_ref` prend 2 paramètres : une liste d'images et une méthode de sélection de référence. Elle renvoie alors une image pouvant servir de référence pour le stacking. Les méthodes de sélection sont les mêmes que pour `stack`. Par exemple : `stack_ref(load_many("\*.fits"), "sharpness")`.
- `dedistort` permet de corriger la distorsion d'une image. Elle dispose de 2 modes d'utilisation distincts. Dans le premier mode, on lui fournit une image de référence et une image à corriger, ainsi que 3 paramètres optionnels : la taille des tuiles, l'échantillonage et la valeur du fond de ciel. Par exemple : `dedistort(ref, img(0), 32, 0.5, 0)`. L'image renvoyée sera corrigée en s'approchant au possible de l'image de référence, la rendant par exemple utilisable pour du stacking. Dans le second mode, on lui fournit une liste d'images à corriger (1er paramètre) et une liste d'images déja corrigées (2d paramètre), auquel cas les paramètres de correction de chaque image est pris en utilisant l'image de même index dans la liste des images déja corrigées. Ceci peut-être utile par exemple lorsqu'on calcule la distorsion sur le centre de la raie (décalage 0) et qu'on souhaite appliquer les mêmes corrections à des images de décalage différent. Par exemple : `dedistort(images, corrected)`.
- `mosaic` permet de créer une mosaïque d'images. Elle prend entre 1 et 3 paramètres. Le premier est la liste des images à empiler, par exemple: `mosaic(load_many("*.fits"))`. Le 2ème paramètre est la taille des tuiles et le 3ème est le facteur de recouvrement (entre 0 et 1).

Fonctions d'analyse :

- `find_shift` permet de calculer un décalage en pixels par rapport à la raie détectée. Elle accepte un seul paramètre, le nom de la raie recherchée, par exemple, `find_shift("Helium (D3)"), ou bien la longueur d'onde en Angström, par exemple `find_shift(5875.62)`. Cette fonction retourne un nombre, le décalage en pixels.
- `continuum` est une fonction sans paramètre qui détermine automatiquement une image de type "continuum" qui peut par exemple être soustraite d'une autre image. Cette fonction diffère de l'image continuum classique au sens où il ne s'agit pas d'une image unique calculée à la différence de pixels fixe de 15 pixels, mais d'une image calculée à partir de la médiane d'un ensemble d'images. Utilisation : `continuum()`.

Filtrage:

La fonction `filter` permet de filtrer une liste d'images pour ne conserver que celles qui correspondent à un critère particulier.
Ceci peut être particulièrement utile en mode batch.
Par exemple, vous pouvez vouloir effectuer un retournement vertical et horizontal des images après un certain temps, en raison du retournement méridien.

La fonction `filter` accepte 4 arguments:

1. la liste d'images à filtrer
2. le sujet du filtrage
3. l'opérateur
4. le critère

Par exemple, pour créer une liste d'images pour lesquelles le temps est après 12:00, vous pouvez utiliser l'appel suivant: `filter(images, "time", ">", "12:00:00")`.

|===
|Sujet|Description|Opérateurs disponibles|Exemple

|`file-name`|Le nom du fichier SER|`=`, `!=`, `contains`, `starts_with`, `ends_with`|`filter(images, "file-name", "contains", "2021-06-01")`
|`dir-name`|Le nom du dossier qui contient le fichier SER|`=`, `!=`, `contains`, `starts_with`, `ends_with`|`filter(images, "dir-name", "contains", "2021-06-01")`
|`pixel-shift`|Le décalage de pixels de l'image|`=`, `!=`, `>`, `<`, `>=`, `<=`|`filter(images, "pixel-shift", ">", 0)`
|`time`|L'heure d'acquisition (comparé en UTC)|`=`, `!=`, `>`, `<`, `>=`, `<=`|`filter(images, "time", ">", "12:00:00")`
|`datetime`|La date et l'heure de l'acquisition (comparée en UTC)|`=`, `!=`, `>`, `<`, `>=`, `<=`|`filter(images, "datetime", ">", "2021-06-01 12:00:00")`
|===

Fonctions spéciales :

- `ar_overlay` génère une image avec les taches solaires détectées. Elle accepte un seul paramètre obligatoire : l'image sur laquelle dessiner les taches. Le deuxième paramètre détermine si le nom de la région doit être affiché (0 = ne pas afficher, 1 = afficher les zones et labels, 2 = seulement les labels). Cette fonction ne fonctionnera que si la génération d'images de taches solaires a été sélectionnée. Par exemple : `ar_overlay(continuum())`.
- `crop_ar` génère une liste d'images correspondant aux taches solaires détectées. Par exemple: `crop_ar(continuum())`. Elle accepte deux paramètres optionnels qui sont la taille minimale des taches, en pixels et une marge en pourcentage. Par exemple: `crop_ar(continuum(), 10, 20)`. La taille par défaut est de 32 pixels.

Fonctions diverses :

- `sort` permet de trier une liste d'images. Elle accepte une liste d'images en premier argument et un critère de tri en second argument. Par exemple : `sort(images, "date")`. Le critère par défaut est `shift` pour le décalage en pixels.
- `video_datetime` retourne la date et l'heure formatée d'une image. Elle accepte un ou deux paramètres : l'image et un format optionnel. Par exemple : `video_datetime(img(0))` ou `video_datetime(img(0), "yyyy-MM-dd HH:mm:ss")`

=== Scripts ImageMath

Dans la section précédente, nous avons vu les "briques élémentaires" d'ImageMath, qui permettent de calculer des images.
Les scripts permettent d'efficacement combiner ces briques pour en faire de véritables outils puissants pour traiter vos images.

A titre d'exemple, voici un script qui permet de traiter une image dans la raie Hélium.

[source]
----
[params]
# The shifting between the helium line and the detected line (in pixels)
Line=5875.62
HeliumShift=find_shift(Line)
# Banding correction width and number of iterations
BandWidth=25
BandIterations=20
# Contrast adjustment
Gamma=1.5
# Autocrop factor (of diameter)
AutoCropFactor=1.1

## Temporary variables
[tmp]
helium_raw = img(HeliumShift) - continuum()
helium_fixed = fix_banding(helium_raw;BandWidth;BandIterations)
cropped = autocrop2(auto_contrast(helium_fixed;Gamma);AutoCropFactor)

## Let's produce the images now!
[outputs]
helium_mono = cropped
helium_color = colorize(helium_mono, Line)
----

Notre script est décomposé en 3 sections: `[params]`, `[tmp]` et `[outputs]`.
La seule section obligatoire est `[outputs]`: elle permet de définir quelles images nous souhaitons obtenir en sortie.
Le nom des autres sections est arbitraire, vous pouvez en définir autant que vous le souhaitez.

Ici, nous avons une section `[params]` qui permet de mettre en évidence les _paramètres de notre script_, autrement dit ce que l'utilisateur peut configurer.
On y trouve des variables, déclarées par un nom (ex `Line`) et une valeur `5875.62`.
La deuxième variable, `HeliumShift`, est calculée à partir de la fonction `find_shift`, qui prend en paramètre la variable `Line` (et permet de déterminer le décalage en pixels de la ligne par rapport à celle détectée).

NOTE: Une variable doit ne peut contenir que des caractères ascii, des numéros (hors premier caractère) ou le caractère _. Par exemple, `maVariable`, `MaVariable0` et `maVariable_0` sont tous valides, mais `hélium` ne l'est pas.

Ces variables peuvent être réutilisés dans d'autres variables ou des appels de fonctions.

IMPORTANT: Les variables sont sensibles à la casse. `maVariable` et `MaVariable` sont 2 variables distinctes !

Ainsi, notre 2ème section, `[tmp]`, définit des images qui nous servent d'intermédiaire de calculs, mais pour lesquelles nous ne sommes pas intéressés par le résultat.
Ici, nous calculons 3 images temporaires :

- `helium_raw` est l'image de la raie Hélium, décalée par rapport à la raie détectée et à laquelle on a soustrait l'image continuum.
- `helium_fixed` est l'image `helium_raw` à laquelle on a appliqué l'algorithme de correction de transversalliums.
- `cropped` est l'image `helium_fixed` à laquelle on a appliqué un rognage automatique et un ajustement de contraste.

Au final, la section `[outputs]` déclare les images qui nous intéressent :

- `helium_mono` est l'image `cropped` telle quelle, en noir et blanc.
- `helium_color = colorize(fix_banding(helium_raw;BandWidth;BandIterations), "Helium (D3)")` permet d'obtenir une version colorisée.

NOTE: Vous pouvez mettre des commentaires sur une ligne commençant par `#` ou `//`

[[trimming-ser-files]]
== Réduire la taille des fichiers SER

Il n'est pas rare d'avoir des fichiers SER qui contiennent beaucoup de trames vides au début ou à la fin, en raison de la façon dont nous capturons généralement les vidéos : nous commençons la capture, puis nous attendons que le montage se stabilise, enfin nous arrêtons la capture.
De plus, notre fenêtre de rognage peut être un peu trop grande pour ce que nous voulons réellement étudier.

En conséquence, les fichiers SER stockés sur le disque sont généralement beaucoup plus grands que ce qu'ils devraient être.
Depuis JSol'Ex 2.10, une nouvelle option est disponible à la fin du traitement d'un fichier.
Vous pouvez cliquer sur le bouton "Réduire SER" en haut à droite de l'interface, ce qui ouvrira une nouvelle fenêtre :

image::trimming-fr.jpg[]

Cette fenêtre est pré-remplie avec des paramètres déduits du fichier traité.
En particulier, les trames de début et de fin, ainsi que les valeurs X mininum et maximum (largeur) sont déterminées automatiquement à partir de la détection du disque solaire dans la vidéo.
Une marge raisonnables de 10% est ajoutée, ce qui signifie que parfois, la première et la dernière trame peuvent en fait correspondre à la vidéo complète si vous avez réellement une vidéo où le soleil apparaît rapidement dans le champ de vision.

Les paramètres "pixels vers le haut"/"pixels vers le bas" correspondent au nombre de pixels que vous souhaitez conserver dans le fichier SER cible autour de la ligne spectrale.
Une fois de plus ces valeurs sont déduites de ce qu'il est possible de faire en corrigeant le "sourire" (courbature de la ligne spectrale), mais il peut être particulièrement intéressant de les réduire, car cela aura un impact important sur la taille du fichier.
Cependant, réduire le nombre de pixels vers le haut/bas supprimera des informations de la vidéo (vous ne pourrez pas calculer d'images avec des décalages de pixels plus importants), alors soyez toujours prudent de ne pas trop les réduire.

Une fois que vous êtes satisfait des paramètres, cliquez sur "Réduire" et un nouveau fichier SER sera créé dans le même dossier que l'original, avec le suffixe `_trimmed`.

Il est important de savoir que la vidéo rognée aura également la correction du sourire appliquée, ce qui signifie que la ligne spectrale sera centrée dans la vidéo et que chaque ligne sera parfaitement horizontale.
Cette information est utilisée par JSol'Ex si vous décidez de traiter la vidéo rognée, de sorte que vous n'ayez pas à recalculer la correction du sourire.

[IMPORTANT]
====
Il est important de comprendre que la réduction de fichier SER est une opération destructive : si vous réduisez le nombre de trames ou les valeurs min x/max x, alors vous tronquez potentiellement le disque solaire ou des caractéristiques comme les protubérances.
Si vous choisissez des valeurs trop faibles pour les pixels vers le haut/bas, alors vous réduisez la bande passante de l'observation, ce qui signifie par exemple que vous ne pourrez plus générer d'image de continuum.
Dans les deux cas, le résultat du traitement de la vidéo rognée sera différent de l'original.
====

Voici un exemple de résultat :

++++
<video width="100%" controls autoplay loop>
  <source src="orig.webm" type="video/webm">
  Your browser does not support the video tag.
</video>
++++

Et la version réduite :

++++
<video width="100%" controls autoplay loop>
  <source src="trimmed.webm" type="video/webm">
  Your browser does not support the video tag.
</video>
++++

[[batch-mode]]
== Traitement par lots

En plus du traitement individuel, JSol'Ex propose une mécanique de traitement par lot.
Dans ce mode, plusieurs vidéos sont traitées en parallèle, permettant de générer rapidement un grand nombre d'images, qui peuvent par exemple être ensuite envoyées dans un logiciel d'empilement tel qu'AutoStakkert!.

Pour lancer un traitement en lot, il faut aller dans le menu "Fichier" et cliquer sur "Traiter un lot".
Sélectionnez alors l'ensemble des fichiers SER à traiter (ils doivent se trouver dans un seul et même dossier).

La même fenètre de paramétrage que dans le mode fichier seul s'ouvre alors.
Elle permet de configurer le traitement, mais cette fois si pour le lot complet.
Lorsque le traitement est lancé, il y a cependant quelques différences:

1. les fichiers seront systématiquement enregistrés, indépendemment de la case "enregistrement automatique des images"
2. les images ne s'affichent pas dans l'interface, mais une liste des fichiers traités à la place

image::batch-mode-fr.jpg[]

La liste des fichiers comprend le _fichier de log_ du traitement de ce fichier, ainsi que toutes les images générées pour ce fichier.

NOTE: En mode batch, nous recommendons d'utiliser un <<#modele-noms-fichier,modèle de nom de fichier>> qui met toutes les images dans le même dossier, ce qui rendra plus simple leur exploitation dans un programme tiers.

=== Passage en revue des images traitées en lot

Une fois qu'un lot a été traité, il est possible de passer en revue les images générées.
Ceci permettra, par exemple, de ne conserver que les images avec un disque sans passage nuageux, ou les images sans déformations.

Pour ce faire, dans les options de traitement, dans l'onglet "divers", cochez la case "Passer en revue les images après traitement en lot" :

image::image-filtering-3-fr.jpg[]

Lorsque le traitement est terminé, une nouvelle fenêtre s'ouvre, vous permettant de passer en revue les images traitées :

image::image-filtering-1-fr.jpg[]

En haut à droite, vous pouvez choisir entre rejeter une image, la conserver, ou la définir comme la meilleure image.
La meilleure image est alors affichée à gauche, et l'image courante à droite.
Vous pouvez ainsi comparer chaque image à la meilleure image, et décider si vous la conservez ou non.

Dans la liste de gauche, vous disposez de la liste des images générées pour chaque fichier SER.
En bas à droite, vous pouvez passer à l'image suivante ou précédente, et terminer le processus.

Lorsque vous avez fini, la fenêtre suivante s'ouvre :

image::image-filtering-2-fr.jpg[]

Elle vous permet de choisir ce que vous voulez faire des images qui ont été rejetées : les conserver, les supprimer, ou les déplacer dans un sous-dossier (par défaut, elles seront déplacées).
De même, vous pouvez choisir ce que vous voulez faire des fichiers SER qui ont servi à générer ces images rejetées : les conserver, les supprimer, ou les déplacer dans un sous-dossier.

Si vous utilisez un script en mode batch, la partie `[[batch]]` du script ne s'exécutera que pour les images que vous avez conservées, ce qui permettra donc, par exemple, de faire un stacking uniquement sur les images de qualité.

A noter que dans les fonctions `stack` et `stack_ref`, vous disposerez alors de la possiblitité de spécifier la méthode de sélection de la référence `manual`, qui choisira alors la meilleure image que vous avez sélectionnée.

[[script-batch]]
=== Extensions d'ImageMath disponibles en mode batch

Lorsque vous utilisez le mode batch, une nouvelle section est disponible dans les <<#imagemath,scripts ImageMath>>.
Cette section permet de composer des images à partir du résultat du traitement de chaque image individuelle.
Typiquement, ceci peut-être utilisé pour faire de l'empilement.

Cette section doit apparaître en fin de script et se délimite par le bloc `\[[batch]]`:

[source]
----
#
# Empile des images en utilisant le mode batch
#

[params]
# banding correction width and iterations
bandingWidth=25
bandingIterations=3
# autocrop factor
cropFactor=1.1
# contrast adjustment
clip=.8

[tmp]
corrected = fix_banding(img(0);bandingWidth;bandingIterations) # <1>
contrast_fixed = clahe(corrected;clip)                         # <2>

[outputs]
cropped = autocrop2(contrast_fixed;cropFactor;32)              # <3>

# This is where we stack images, simply using a median
# and assuming all images will have the same output size
[[batch]]                                                      # <4>
[outputs]
stacked=sharpen(median(cropped))                               # <5>
----
<1> Pour chaque film, on calcule une image intermédiaire corrigée (qui ne sera pas stockée sur disque)
<2> On applique une correction de contraste sur cette image corrigée
<3> Important pour l'empilement : on réduit les images à un carré centré sur le disque solaire et on arondit les dimensions à un multiple de 32 pixels. Il s'agit de notre image de sortie pour chaque film du lot.
<4> On déclare une section `\[[batch]]` pour décrire la sortie du mode batch
<5> Une image nommée `stacked` sera calculée en utilisant la médiane des images `cropped`

Il est important de bien comprendre que seules les images apparaissant dans la partie `[outputs]` du traitement individiduel peuvent être utilisées dans la section `\[[batch]]`.
Ainsi, une image `cropped` apparaissant dans la partie individuelle devient implicitement une _liste_ d'images dans la section `\[[batch]]`: on travaille bien sur la liste des images générées dans le lot !

Certaines fonctions comme `img` ne sont pas disponibles dans le mode `batch`.
Si vous avez besoin d'images individuelles, vous devez les stocker dans une variable de sortie.
Par exemple:

[source]
----
[outputs]
frame=img(0)       # <1>

[[batch]]
[outputs]
video=anim(frame)  # <2>
----
<1> Pour que `img(0)` soit disponible dans la section `batch`, on l'assigne dans une variable nommée `frame`
<2> On crée une animation dont chaque image est constituée d'une `frame`

=== Scripts indépendants

Une dernière façon d'utiliser des scripts est de réutiliser des résultats de sessions précédentes (typiquement des images traitées lors d'une ou plusieurs sessions) sans avoir besoin de traiter une nouvelle vidéo.

Pour se faire, vous pouvez passer par le menu "Outils" puis "Editeur ImageMath".
L'interface qui apparaît est exactement la même que lors du traitement d'une vidéo ou d'un lot de vidéos.
La principale différence dans ce mode est que les images doivent être chargées avec les fonctions `load` ou `load_many` (au lieu d'utiliser `img`).

IMPORTANT: Si vous utilisez ce mode, il est important de charger des images enregistrées au format FITS. En effet, ces images contiennent des métadonnées telles que les ellipses détectées, les paramètres de traitement, etc. qui permettent de faire les mêmes traitements avec des images enregistrées sur disque que ceux obtenus dans une session de traitement classique.

== Mesures

=== Mesures de décalage vers le rouge

Si vous traitez une image H-alpha, JSol'Ex peut automatiquement rechercher dans l'image des régions où le _redshift_ (décalage vers le rouge ou vers le bleu) est particulièrement fort.

Pour se faire, vous devez soit sélectionner le mode "complet" lors du traitement, soit cocher la case "Mesures de décalage vers le rouge" dans la sélection personnalisée des images.

Les mesures ne seront valides **que** si la taille des pixels renseignée est correcte **et** que vous utilisez un Sol'Ex (d'autres spectrohéliographes ont des focales différentes).

Lors du traitement, une image supplémentaire sera générée avec les régions entourées en rouge et la vitesse associée.

De plus, si vous sélectionnez les images de débug, les parties du spectre ayant permis de trouver ces régions seront affichées.

Enfin, une fois la détection effectuée, il vous est possible de générer 2 nouveaux types de rendus, en vous rendant sur l'onglet "Redshift":

image::redshift-tab.jpg[]

La taille correspond à la taille minimale de la région à capturer, en pixels.
Une petite région sera centrée autour du filament détecté, mais pourra être assez pixelisée selon les cas.
La marge permet de choisir combien, en décalage de pixels, prendre de marge par rapport à ce qu'a détecté JSol'Ex.
Par exemple, JSol'Ex peut trouver un décalage maximum de 20 pixels, mais vous pouvez souhaiter ajouter 2 ou 4 pixels de marge pour une animation et bien voir apparaître le filament.

Enfin, sélectionnez le type de rendu :

- Animation : génère une vidéo dont chaque image est décalée de 0.25 pixels
- Panneau : génère une seule image, un panneau où chaque case correspond à un décalage de pixels différent

image::pixel-shift-panel.jpg["Example of panel"]

=== Mesures avec l'analyseur de vidéo

JSol'Ex propose un outil permettant de visualiser la détection des lignes spectrales sur une vidéo.
Cet outil peut être utilisé pour trouver, par exemple, le décalage de pixels à appliquer pour trouver la raie hélium.

Pour se faire, ouvrez une vidéo en cliquant sur "Outils -> Analyseur de vidéo".
Le logiciel va calculer l'image moyenne pour la vidéo puis vous présenter cette fenêtre:

image::spectral-debug-1-fr.jpg[]

En haut, vous voyez l'image moyenne.
La ligne rouge correspond à la ligne spectrale détectée.
Sous la ligne violette s'affiche une image _corrigée en fonction du polynôme_ : ceci vous permet de vérifier facilement si le polynôme est correct: l'image du bas doit avoir des lignes spectrales parfaitement horizontales.

Dans la partie basse de l'interface, vous trouverez:

- le bouton radio "Moyenne / Images" qui permet de basculer entre l'image moyenne et les images individuelles du film SER
- lorsque "Images" est sélectionné, le slider à droite permet de naviguer dans la vidéo
- le seuil de détection du soleil peut être changé (non recommandé, le logiciel ne permet pas de modifier cette valeur, c'est un mode expert)
- la case "vérouiller le polynôme" permet de figer la détection de ligne spectrale sur l'image actuelle : elle nous sera utile pour les mesures de distances
- le slider "contraste" permet d'augmenter le contraste et la luminosité de l'image (transformation arcsin hyperbolique)

=== Application au calcul de décalage de la raie hélium

Nous supposerons ici que notre fichier SER est une vidéo incluant à la fois la raie spectrale Hélium et une autre raie suffisamment sombre pour être bien détectée par JSol'Ex.

Nous pouvons alors procéder par étapes.

- vérouiller le polynôme sur l'image moyenne

image::spectral-debug-2-fr.jpg[]

- sélectionner le mode "Images"

image::spectral-debug-3-fr.jpg[]

- Augmenter le contraste

image::spectral-debug-4-fr.jpg[]

- Choisir une image au bord du limbe

image::spectral-debug-5-fr.jpg[]

Nous pouvons désormais effectuer des mesures.
Lorsque vous déplacez la souris sur l'image, des coordonnées s'affichent :

image::spectral-debug-6-fr.jpg[]

Les 2 premiers nombres sont les coordonnées (x,y) du point sous le curseur de la souris.
Le 3ème nombre est celui qui nous intéresse : c'est le décalage en pixels entre le point sous le curseur et la ligne spectrale en rouge.

Le 4ème nombre nous permet d'obtenir une mesure plus précise, en calculant une moyenne sur un nombre d'échantillons.

Pour ajouter un échantillon, trouvez un point sur la raie hélium et appuyez sur "CTRL" tout en cliquant.
Vous pouvez ajouter autant de points que vous le souhaitez:

image::spectral-debug-7-fr.jpg[]

Le 4ème nombre représente la distance moyenne calculée.
**Nous en déduisons que le décalage de pixels à appliquer est de -134**.

[[stacking-and-mosaic]]
== Empilement et création de mosaiques

JSol'Ex dispose d'un outil permettant d'empiler des images et de créer des mosaïques.
Les 2 outils sont très similaires, mais l'empilement est plus simple à utiliser.
L'empilement consiste à prendre plusieurs images de la même région du soleil et à en faire une seule image, en alignant les détails et en moyennant les pixels.
La mosaïque consiste à prendre plusieurs images de régions différentes du soleil et à les assembler pour former une image plus grande.

Les 2 outils sont disponibles en passant par le menu "Outils" puis "Empilement et création de mosaïques".

La fenêtre qui s'ouvre est la suivante:

image::stacking-1-fr.jpg[]

A gauche, vous pouvez créer des panneaux d'images à empiler.
Si vous ne créez qu'un seul panneau, il s'agira d'un empilement simple.
Si vous créer plusieurs panneaux, il s'agira d'une mosaïque.
Un panneau contiendra une ou plusieurs images, qui seront empilées ensemble.
Pour créer un panneau, vous pouvez, au choix:
- cliquer sur le bouton "+" et sélectionner les images à empiler
- faire un glisser-déposer d'une ou plusieurs images depuis votre explorateur de fichiers

image::stacking-2-fr.jpg[]

Dans l'image ci-dessus, nous avons créé 2 panneaux.
Le premier contient 3 images qui seront empilées pour faire le panneau nord, et le second contient 2 images qui seront empilées pour faire le panneau sud.

Les options d'empilement sont visibles à droite.
Il n'est pas recommandé de les modifier, sauf si vous savez ce que vous faites.
Les options sont les suivantes:

- la taille des tuiles permet de découper l'image en tuiles pour l'empilement. Plus la taille est petite, plus l'empilement sera précis mais le calcul sera plus long et il ne sera pas possible de découvrir des décalages importants entre les images.
- l'échantillonage permet de déterminer où seront pris les échantillons servant à calculer le modèle de distorsion. Un facteur de 0.5 combiné à des tuiles de 32 pixels signifie par exemple un échantillon tous les 16 pixels.
- Forcer le recalcul des ellipses permet de recalculer l'ellipse (ou le cercle) du disque solaire pour chaque image. Ceci est utile notamment si vous utilisez des images venant d'un autre logiciel ou que les ellipses ont été mal détectées.
- Corriger la géométrie permet de rendre le disque solaire parfaitement circulaire, ce qui est généralement une bonne idée si les images que vous importez n'ont pas été corrigées.

Le script de post-traitement vous permet de sélectionner un script `ImageMath` à appliquer à chaque image après empilement.

NOTE: Dans un script de post-traitement, l'image empilée est disponible sous le nom de `image`. Par exemple, vous pouvez créer un script qui appliquera une déconvolution en utilisant la formule `rl_decon(image)`.

Les autres options disponibles sont celles de sélection des formats de fichier.
Si vous avez créé plusieurs panneaux, nous passons alors en mode mosaïque.
Non seulement les images seront empilées dans chaque panneau, mais chaque image empilée sera ensuite assemblée pour former une mosaïque.

WARNING: Il est recommandé de ne PAS utiliser d'images traitées (par exemple avec amélioration de contraste) pour la création de mosaïques. En effet, ces images sont plus difficiles à aligner. Il est donc recommandé d'utiliser les images `recon` (corrigée géométriquement) ou `raw` (brute).

image::stacking-3-fr.jpg[]

Si vous souhaitez simplement empiler des images sans faire de mosaique, vous pouvez désactiver l'option "Créer la mosaïque".
Dans le cas contraire, vous disposez de paramètres qu'il est possible de modifier, encore une fois, si vous savez ce que vous faites.
Nous recommandons de ne pas changer la taille des tuiles et le chevauchement pour la mosaïque, sauf si vous obtenez des images déformées ou non reconstruites.

Vous pouvez aussi choisir un script de post-traitement à appliquer après la création de la mosaïque.

== Calculatrice d'exposition optimale

Dans le menu "Outils", vous trouverez la calculatrice d'exposition optimale.
Cette calculatrice vous permet de déterminer le temps d'exposition optimal que vous devrez utiliser pour obtenir une image du soleil parfaitement ronde et éviter le sous-échantillonage.

Entrez :

- la taille des pixels de votre caméra et le binning utilisé
- la longueur focale de votre instrument
- la vitesse du scan (en multiple de la vitesse sidérale, par exemple 2, 4, 8, ...)
- la date d'observation

Le logiciel calculera alors le framerate recommandé annsi que l'exposition optimale en fonction de ces paramètres, en millisecondes.

Notez que vous pouvez changer le type de spectrohéliographe utilisé, ce qui peut changer le calcul de l'exposition optimale.

== Explorateur de spectre

L'explorateur de spectre est disponible dans le menu "Outils".
Il permet de visualiser l'aspect du spectre tel qu'il serait vu dans un logiciel de capture tel que SharpCap ou FireCapture.
Il vous permet de vous "promener" dans le spectre :

image::spectrum-browser-1.jpg[]

Dans la case "Longueur d'onde", vous pouvez saisir une longueur d'onde en Angströms.
En cliquant sur "Aller" ou en tapant entrée, le spectre sera automatiquement centré autour de cette longueur d'onde :

image::spectrum-browser-2.jpg[]

Une ligne pointillée bleue est ajoutée, vous permettant de bien repérer la ligne.

Alternativement, vous pouvez rechercher directement une ligne spectrale remarquable en la sélectionnant dans la boîte à côté du bouton "Aller".

Lorsque vous cliquez sur "Coloriser", le spectre est alors colorisé de façon à vous donner une idée d'où vous vous situez dans le spectre visible (nous recommandons cependant de rester en niveaux de gris pour repérer précisément une raie) :

image::spectrum-browser-3.jpg[]

Sur la deuxième ligne, vous avez la possibilité de choisir le spectrohéliographe qui a été utilisé (celui-ci aura une influence sur la dispersion spectrale calculée), ainsi que de préciser la taille des pixels (pensez à multiplier par le _binning_).

Si vous cochez la case "Ajuster dispersion", la dimension du spectre est automatiquement ajustée pour correspondre précisément à la dispersion par pixel.

Vous pouvez zoomer soit en cliquant sur les boutons "+" et "-", ou, plus simplement, en appuyant sur "CTRL" et en faisant tourner votre molette de souris.
Si vous zoomez, l'ajustement automatique est désactivé (puisqu'il ne correspond plus à la dispersion exacte par pixel).

=== Identification automatique

Enfin, JSol'Ex propose une fonctionnalité encore expérimentale : vous pouvez cliquer sur le bouton "Identifier" pour ouvrir une fenêtre de sélection de fichier.

Choisissez alors une image du spectre, telle que capturée par votre logiciel.
JSol'Ex essayera alors de retrouver dans quelle partie du spectre elle se trouve :

image::spectrum-browser-4.jpg[]

Si l'identification fonctionne, votre image sera affichée en transparence, par dessus le spectre, sur la partie gauche de l'image, ce qui vous permettra de vérifier facilement si l'identification a réussi.

Vous pouvez masquer l'image en transparence en cliquant sur le bouton "Cacher".

== Serveur Web embarqué

Dans le menu "Outils", vous trouverez la possibilité de lancer un serveur web embarqué.
Ce serveur permet de voir les images traitées par le logiciel depuis d'autres ordinateurs, en se connectant à ce serveur.

Cette fonctionalité peut-être particulièrement pratique lors de projections publiques, en ayant un ordinateur utilisant JSol'Ex pour l'acquisition des images et un autre ordinateur sur le même réseau pour la projection sur un écran.

image::embedded-server-1-fr.jpg[]

Vous pouvez configurer le port sur lequel le serveur écoute et disposez de la possibilité de le lancer automatiquement au démarrage du logiciel.

L'interface donne accès aux images en cours de traitement ainsi qu'à leur historique, au cas où vous traitez plusieurs images successivement.

image::embedded-server-2-fr.jpg[]

== Remerciements

- Christian Buil pour avoir conçu le Sol'Ex et diriger la communauté d'une main de maître
- Valérie Desnoux pour son travail remarquable sur INTI
- Jean-François Pittet pour ses rapports de bugs, ses vidéos de test et ses formules de correction géométrique
- Sylvain Weiller pour son beta-testing intensif, ses retours précieux et ses idées de traitement
- Ken M. Harrison pour l'amélioration des calculs d'exposition optimale
